package com.github.jg513.webpb.writers.wire;

import com.github.jg513.webpb.core.context.SchemaContext;
import com.github.jg513.webpb.core.specs.PendingServiceSpec;
import com.github.jg513.webpb.core.specs.PendingSpec;
import com.github.jg513.webpb.core.specs.PendingTypeSpec;
import com.squareup.wire.WireLogger;
import com.squareup.wire.java.JavaGenerator;
import com.squareup.wire.java.Profile;
import com.squareup.wire.java.ProfileLoader;
import com.squareup.wire.schema.ProtoFile;
import com.squareup.wire.schema.PruningRules;
import com.squareup.wire.schema.Schema;
import com.squareup.wire.schema.SchemaLoader;
import kotlin.Unit;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.Path;
import java.util.AbstractQueue;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.stream.Collectors;

public class WireCompiler {
    public static final String CODE_GENERATED_BY_WIRE
        = "Code generated by Wire protocol buffer compiler, do not edit.";

    private static final String DESCRIPTOR_PROTO = "google/protobuf/descriptor.proto";

    public static final int MAX_WRITE_CONCURRENCY = 8;

    @NotNull
    private final FileSystem fs;

    @NotNull
    private final WireLogger log;

    @NotNull
    private final List<String> protoPaths;

    @Nullable
    private final String javaOut;

    @Nullable
    private final String kotlinOut;

    @NotNull
    private final List<String> sourceFileNames;

    @NotNull
    private final PruningRules pruningRules;

    private final boolean dryRun;

    private final boolean namedFilesOnly;

    private final boolean emitAndroid;

    private final boolean emitAndroidAnnotations;

    private final boolean emitCompact;

    private final boolean javaInterop;

    public WireCompiler(
        @NotNull FileSystem fs,
        @NotNull WireLogger log,
        @NotNull List<String> protoPaths,
        @Nullable String javaOut,
        @Nullable String kotlinOut,
        @NotNull List<String> sourceFileNames,
        @NotNull PruningRules pruningRules,
        boolean dryRun, boolean namedFilesOnly,
        boolean emitAndroid,
        boolean emitAndroidAnnotations,
        boolean emitCompact,
        boolean javaInterop) {

        this.fs = fs;
        this.log = log;
        this.protoPaths = protoPaths;
        this.javaOut = javaOut;
        this.kotlinOut = kotlinOut;
        this.sourceFileNames = sourceFileNames;
        this.pruningRules = pruningRules;
        this.dryRun = dryRun;
        this.namedFilesOnly = namedFilesOnly;
        this.emitAndroid = emitAndroid;
        this.emitAndroidAnnotations = emitAndroidAnnotations;
        this.emitCompact = emitCompact;
        this.javaInterop = javaInterop;
    }

    public final void compile() throws IOException {
        SchemaLoader schemaLoader = new SchemaLoader();
        this.protoPaths.forEach(p -> {
            Path path = this.fs.getPath(p);
            schemaLoader.addSource(path);
        });
        this.sourceFileNames.forEach(schemaLoader::addProto);

        Schema schema = schemaLoader.load();
        if (!pruningRules.isEmpty()) {
            log.info("Analyzing dependencies of root types.");
            schema = schema.prune(pruningRules);
            pruningRules.unusedIncludes().forEach(v -> log.info("Unused include: " + v));
            pruningRules.unusedExcludes().forEach(v -> log.info("Unused exclude: " + v));
        }

        AbstractQueue<PendingSpec> queue = new ConcurrentLinkedQueue<>();
        for (ProtoFile protoFile : schema.getProtoFiles()) {
            String path = protoFile.getLocation().getPath();
            if (!sourceFileNames.isEmpty() && !sourceFileNames.contains(path)) {
                if (namedFilesOnly || DESCRIPTOR_PROTO.equals(path)) {
                    continue;
                }
            }
            queue.addAll(protoFile.getTypes().stream()
                .map(type -> new PendingTypeSpec(protoFile, type))
                .collect(Collectors.toList())
            );
            queue.addAll(protoFile.getServices().stream()
                .map(service -> new PendingServiceSpec(protoFile, service))
                .collect(Collectors.toList())
            );
        }

        ExecutorService executor = Executors.newCachedThreadPool();
        List<Future<Unit>> futures = new ArrayList<>(MAX_WRITE_CONCURRENCY);

        if (javaOut != null) {
            String profileName = emitAndroid ? "android" : "java";
            Profile profile = new ProfileLoader(profileName)
                .schema(schema)
                .load();

            JavaGenerator javaGenerator = JavaGenerator.get(schema)
                .withProfile(profile)
                .withAndroid(emitAndroid)
                .withAndroidAnnotations(emitAndroidAnnotations)
                .withCompact(emitCompact);

            ConcurrentLinkedQueue<PendingTypeSpec> types = queue.stream()
                .filter(v -> v instanceof PendingTypeSpec)
                .map(v -> (PendingTypeSpec) v)
                .collect(Collectors.toCollection(ConcurrentLinkedQueue::new));
            SchemaContext context = new SchemaContext(schema);
            for (int i = 0; i < MAX_WRITE_CONCURRENCY; i++) {
                Callable<Unit> task = new JavaFileWriter(context, javaOut, javaGenerator, types, dryRun, fs, log);
                futures.add(executor.submit(task));
            }
        } else {
            throw new AssertionError();
        }

        executor.shutdown();

        try {
            for (Future<Unit> future : futures) {
                future.get();
            }
        } catch (ExecutionException e) {
            throw new IOException(e.getMessage(), e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }
}
