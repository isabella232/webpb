// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: google/protobuf/any.proto
package com.google.protobuf;

import com.github.jg513.webpb.core.WebpbMessage;
import com.github.jg513.webpb.options.MessageOptions;
import com.squareup.wire.FieldEncoding;
import com.squareup.wire.Message;
import com.squareup.wire.ProtoAdapter;
import com.squareup.wire.ProtoReader;
import com.squareup.wire.ProtoWriter;
import com.squareup.wire.WireField;
import com.squareup.wire.internal.Internal;
import java.io.IOException;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;
import okio.ByteString;

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes
 * the type of the serialized message.
 *
 * <p>Protobuf library provides support to pack/unpack Any values in the form of utility functions
 * or additional generated methods of the Any type.
 *
 * <p>Example 1: Pack and unpack a message in C++.
 *
 * <p>Foo foo = ...; Any any; any.PackFrom(foo); ... if (any.UnpackTo(&foo)) { ... }
 *
 * <p>Example 2: Pack and unpack a message in Java.
 *
 * <p>Foo foo = ...; Any any = Any.pack(foo); ... if (any.is(Foo.class)) { foo =
 * any.unpack(Foo.class); }
 *
 * <p>Example 3: Pack and unpack a message in Python.
 *
 * <p>foo = Foo(...) any = Any() any.Pack(foo) ... if any.Is(Foo.DESCRIPTOR): any.Unpack(foo) ...
 *
 * <p>Example 4: Pack and unpack a message in Go
 *
 * <p>foo := &pb.Foo{...} any, err := ptypes.MarshalAny(foo) ... foo := &pb.Foo{} if err :=
 * ptypes.UnmarshalAny(any, foo); err != nil { ... }
 *
 * <p>The pack methods provided by protobuf library will by default use
 * 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully
 * qualified type name after the last '/' in the type URL, for example "foo.bar.com/x/y.z" will
 * yield type name "y.z".
 *
 * <p>JSON ==== The JSON representation of an `Any` value uses the regular representation of the
 * deserialized, embedded message, with an additional field `@type` which contains the type URL.
 * Example:
 *
 * <p>package google.profile; message Person { string first_name = 1; string last_name = 2; }
 *
 * <p>{ "@type": "type.googleapis.com/google.profile.Person", "firstName": <string>, "lastName":
 * <string> }
 *
 * <p>If the embedded message type is well-known and has a custom JSON representation, that
 * representation will be embedded adding a field `value` which holds the custom JSON in addition to
 * the `@type` field. Example (for message [google.protobuf.Duration][]):
 *
 * <p>{ "@type": "type.googleapis.com/google.protobuf.Duration", "value": "1.212s" }
 */
@Getter
@Setter
@Accessors(chain = true)
public final class Any extends Message<Any, Any.Builder> implements WebpbMessage {

    public static final MessageOptions MESSAGE_OPTIONS = new MessageOptions.Builder().build();

    public static final ProtoAdapter<Any> ADAPTER = new ProtoAdapter_Any();

    private static final long serialVersionUID = 0L;

    public static final String DEFAULT_TYPE_URL = "";

    public static final ByteString DEFAULT_VALUE = ByteString.EMPTY;

    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer
     * message. This string must contain at least one "/" character. The last segment of the URL's
     * path must represent the fully qualified name of the type (as in
     * `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading "."
     * is not accepted).
     *
     * <p>In practice, teams usually precompile into the binary all types that they expect it to use
     * in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme,
     * one can optionally set up a type server that maps type URLs to message definitions as
     * follows:
     *
     * <p>* If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a
     * [google.protobuf.Type][] value in binary format, or produce an error. * Applications are
     * allowed to cache lookup results based on the URL, or have them precompiled into a binary to
     * avoid any lookup. Therefore, binary compatibility needs to be preserved on changes to types.
     * (Use versioned type names to manage breaking changes.)
     *
     * <p>Note: this functionality is not currently available in the official protobuf release, and
     * it is not used for type URLs beginning with type.googleapis.com.
     *
     * <p>Schemes other than `http`, `https` (or the empty scheme) might be used with implementation
     * specific semantics.
     */
    @WireField(tag = 1, adapter = "com.squareup.wire.ProtoAdapter#STRING", jsonName = "typeUrl")
    private String type_url;

    /** Must be a valid serialized protocol buffer of the above specified type. */
    @WireField(tag = 2, adapter = "com.squareup.wire.ProtoAdapter#BYTES")
    private ByteString value;

    public Any() {
        super(ADAPTER, ByteString.EMPTY);
    }

    public Any(String type_url, ByteString value) {
        this(type_url, value, ByteString.EMPTY);
    }

    public Any(String type_url, ByteString value, ByteString unknownFields) {
        super(ADAPTER, unknownFields);
        this.type_url = type_url;
        this.value = value;
    }

    @Override
    public MessageOptions messageOptions() {
        return MESSAGE_OPTIONS;
    }

    @Override
    public Builder newBuilder() {
        Builder builder = new Builder();
        builder.type_url = type_url;
        builder.value = value;
        builder.addUnknownFields(unknownFields());
        return builder;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) return true;
        if (!(other instanceof Any)) return false;
        Any o = (Any) other;
        return unknownFields().equals(o.unknownFields())
                && Internal.equals(type_url, o.type_url)
                && Internal.equals(value, o.value);
    }

    @Override
    public int hashCode() {
        int result = super.hashCode;
        if (result == 0) {
            result = unknownFields().hashCode();
            result = result * 37 + (type_url != null ? type_url.hashCode() : 0);
            result = result * 37 + (value != null ? value.hashCode() : 0);
            super.hashCode = result;
        }
        return result;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        if (type_url != null) builder.append(", type_url=").append(Internal.sanitize(type_url));
        if (value != null) builder.append(", value=").append(value);
        return builder.replace(0, 2, "Any{").append('}').toString();
    }

    public static final class Builder extends Message.Builder<Any, Builder> {

        public String type_url;

        public ByteString value;

        public Builder() {}

        /**
         * A URL/resource name that uniquely identifies the type of the serialized protocol buffer
         * message. This string must contain at least one "/" character. The last segment of the
         * URL's path must represent the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading
         * "." is not accepted).
         *
         * <p>In practice, teams usually precompile into the binary all types that they expect it to
         * use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no
         * scheme, one can optionally set up a type server that maps type URLs to message
         * definitions as follows:
         *
         * <p>* If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a
         * [google.protobuf.Type][] value in binary format, or produce an error. * Applications are
         * allowed to cache lookup results based on the URL, or have them precompiled into a binary
         * to avoid any lookup. Therefore, binary compatibility needs to be preserved on changes to
         * types. (Use versioned type names to manage breaking changes.)
         *
         * <p>Note: this functionality is not currently available in the official protobuf release,
         * and it is not used for type URLs beginning with type.googleapis.com.
         *
         * <p>Schemes other than `http`, `https` (or the empty scheme) might be used with
         * implementation specific semantics.
         */
        public Builder type_url(String type_url) {
            this.type_url = type_url;
            return this;
        }

        /** Must be a valid serialized protocol buffer of the above specified type. */
        public Builder value(ByteString value) {
            this.value = value;
            return this;
        }

        @Override
        public Any build() {
            return new Any(type_url, value, super.buildUnknownFields());
        }
    }

    private static final class ProtoAdapter_Any extends ProtoAdapter<Any> {

        public ProtoAdapter_Any() {
            super(
                    FieldEncoding.LENGTH_DELIMITED,
                    Any.class,
                    "type.googleapis.com/google.protobuf.Any");
        }

        @Override
        public int encodedSize(Any value) {
            return ProtoAdapter.STRING.encodedSizeWithTag(1, value.type_url)
                    + ProtoAdapter.BYTES.encodedSizeWithTag(2, value.value)
                    + value.unknownFields().size();
        }

        @Override
        public void encode(ProtoWriter writer, Any value) throws IOException {
            ProtoAdapter.STRING.encodeWithTag(writer, 1, value.type_url);
            ProtoAdapter.BYTES.encodeWithTag(writer, 2, value.value);
            writer.writeBytes(value.unknownFields());
        }

        @Override
        public Any decode(ProtoReader reader) throws IOException {
            Builder builder = new Builder();
            long token = reader.beginMessage();
            for (int tag; (tag = reader.nextTag()) != -1; ) {
                switch (tag) {
                    case 1:
                        builder.type_url(ProtoAdapter.STRING.decode(reader));
                        break;
                    case 2:
                        builder.value(ProtoAdapter.BYTES.decode(reader));
                        break;
                    default:
                        {
                            reader.readUnknownField(tag);
                        }
                }
            }
            builder.addUnknownFields(reader.endMessageAndGetUnknownFields(token));
            return builder.build();
        }

        @Override
        public Any redact(Any value) {
            Builder builder = value.newBuilder();
            builder.clearUnknownFields();
            return builder.build();
        }
    }
}
