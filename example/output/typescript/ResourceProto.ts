// Code generated by Webpb compiler, do not edit.
// https://github.com/jg513/webpb

import * as $protobuf from "protobufjs";
import { Webpb } from 'webpb';

const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

export namespace ResourceProto {
    export interface IPageablePb {
        pagination?: boolean;
        page?: number;
        size?: number;
        sort?: string;
    }

    export class PageablePb implements IPageablePb {
        pagination?: boolean;
        page?: number;
        size?: number;
        sort?: string;
        META: () => Webpb.WebpbMeta;

        private constructor(p?: IPageablePb) {
            Webpb.assign(p, this, []);
            this.META = () => (p && {
                class: 'PageablePb',
                method: '',
                path: ''
            });
        }

        static create(properties: IPageablePb): PageablePb {
            return new PageablePb(properties);
        }

        static encode(message: IPageablePb, writer?: $protobuf.Writer): $protobuf.Writer {
            writer || (writer = $Writer.create());
            if (message.pagination != null && message.hasOwnProperty("pagination")) {
                writer.uint32(8).bool(message.pagination);
            }
            if (message.page != null && message.hasOwnProperty("page")) {
                writer.uint32(16).int32(message.page);
            }
            if (message.size != null && message.hasOwnProperty("size")) {
                writer.uint32(24).int32(message.size);
            }
            if (message.sort != null && message.hasOwnProperty("sort")) {
                writer.uint32(34).string(message.sort);
            }
            return writer;
        }

        static encodeDelimited(message: IPageablePb, writer?: $protobuf.Writer): $protobuf.Writer {
            return this.encode(message, writer).ldelim();
        }

        static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): ResourceProto.PageablePb {
            (reader instanceof $Reader) || (reader = $Reader.create(reader));
            let end = length === undefined ? reader.len : reader.pos + length;
            let message = new ResourceProto.PageablePb();
            while (reader.pos < end) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1: {
                        message.pagination = reader.bool();
                        break;
                    }
                    case 2: {
                        message.page = reader.int32();
                        break;
                    }
                    case 3: {
                        message.size = reader.int32();
                        break;
                    }
                    case 4: {
                        message.sort = reader.string();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        }

        static decodeDelimited(reader: ($protobuf.Reader | Uint8Array)): ResourceProto.PageablePb {
            (reader instanceof $Reader) || (reader = new $Reader(reader));
            return this.decode(reader, reader.uint32());
        }

        static toObject(message: IPageablePb, options?: $protobuf.IConversionOptions): { [k: string]: any } {
            options || (options = {});
            let obj : { [k: string]: any } = {};
            if (options.defaults) {
                obj.pagination = false;
                obj.page = 0;
                obj.size = 0;
                obj.sort = "";
            }
            if (message.pagination != null && message.hasOwnProperty("pagination")) {
                obj.pagination = message.pagination;
            }
            if (message.page != null && message.hasOwnProperty("page")) {
                obj.page = message.page;
            }
            if (message.size != null && message.hasOwnProperty("size")) {
                obj.size = message.size;
            }
            if (message.sort != null && message.hasOwnProperty("sort")) {
                obj.sort = message.sort;
            }
            return obj;
        }

        toJSON(): { [k: string]: any } {
            return ResourceProto.PageablePb.toObject(this, $protobuf.util.toJSONOptions);
        }
    }

    export interface IPagingPb {
        page: number;
        size: number;
        totalCount: number;
        totalPage: number;
    }

    export class PagingPb implements IPagingPb {
        page!: number;
        size!: number;
        totalCount!: number;
        totalPage!: number;
        META: () => Webpb.WebpbMeta;

        private constructor(p?: IPagingPb) {
            Webpb.assign(p, this, []);
            this.META = () => (p && {
                class: 'PagingPb',
                method: '',
                path: ''
            });
        }

        static create(properties: IPagingPb): PagingPb {
            return new PagingPb(properties);
        }

        static encode(message: IPagingPb, writer?: $protobuf.Writer): $protobuf.Writer {
            writer || (writer = $Writer.create());
            writer.uint32(8).int32(message.page);
            writer.uint32(16).int32(message.size);
            writer.uint32(24).int32(message.totalCount);
            writer.uint32(32).int32(message.totalPage);
            return writer;
        }

        static encodeDelimited(message: IPagingPb, writer?: $protobuf.Writer): $protobuf.Writer {
            return this.encode(message, writer).ldelim();
        }

        static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): ResourceProto.PagingPb {
            (reader instanceof $Reader) || (reader = $Reader.create(reader));
            let end = length === undefined ? reader.len : reader.pos + length;
            let message = new ResourceProto.PagingPb();
            while (reader.pos < end) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1: {
                        message.page = reader.int32();
                        break;
                    }
                    case 2: {
                        message.size = reader.int32();
                        break;
                    }
                    case 3: {
                        message.totalCount = reader.int32();
                        break;
                    }
                    case 4: {
                        message.totalPage = reader.int32();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
                if (!message.hasOwnProperty("page")) {
                    throw $util.ProtocolError("missing required 'page'", { instance: message });
                }
                if (!message.hasOwnProperty("size")) {
                    throw $util.ProtocolError("missing required 'size'", { instance: message });
                }
                if (!message.hasOwnProperty("totalCount")) {
                    throw $util.ProtocolError("missing required 'totalCount'", { instance: message });
                }
                if (!message.hasOwnProperty("totalPage")) {
                    throw $util.ProtocolError("missing required 'totalPage'", { instance: message });
                }
            }
            return message;
        }

        static decodeDelimited(reader: ($protobuf.Reader | Uint8Array)): ResourceProto.PagingPb {
            (reader instanceof $Reader) || (reader = new $Reader(reader));
            return this.decode(reader, reader.uint32());
        }

        static toObject(message: IPagingPb, options?: $protobuf.IConversionOptions): { [k: string]: any } {
            options || (options = {});
            let obj : { [k: string]: any } = {};
            if (options.defaults) {
                obj.page = 0;
                obj.size = 0;
                obj.totalCount = 0;
                obj.totalPage = 0;
            }
            if (message.page != null && message.hasOwnProperty("page")) {
                obj.page = message.page;
            }
            if (message.size != null && message.hasOwnProperty("size")) {
                obj.size = message.size;
            }
            if (message.totalCount != null && message.hasOwnProperty("totalCount")) {
                obj.totalCount = message.totalCount;
            }
            if (message.totalPage != null && message.hasOwnProperty("totalPage")) {
                obj.totalPage = message.totalPage;
            }
            return obj;
        }

        toJSON(): { [k: string]: any } {
            return ResourceProto.PagingPb.toObject(this, $protobuf.util.toJSONOptions);
        }
    }
}
