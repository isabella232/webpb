// Code generated by Webpb compiler, do not edit.
// https://github.com/jg513/webpb

import * as $protobuf from "protobufjs";
import { Webpb } from 'webpb';

const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

export namespace ResourceProto {
    export interface IPageablePb {
        pagination?: boolean;
        page?: number;
        size?: number;
        sort?: string;
    }

    export class PageablePb implements IPageablePb {
        pagination?: boolean;
        page?: number;
        size?: number;
        sort?: string;
        META: () => Webpb.WebpbMeta;

        private constructor(p: IPageablePb) {
            Webpb.assign(p, this, []);
            this.META = () => ({
                class: 'PageablePb',
                method: '',
                path: ''
            });
        }

        static create(properties: IPageablePb): PageablePb {
            return new PageablePb(properties);
        }

        static encode(message: IPageablePb, writer?: $protobuf.Writer): $protobuf.Writer {
            if (!writer) {
                writer = $Writer.create();
            }
            if (message.pagination != null && message.hasOwnProperty("pagination")) {
                writer.uint32(8).bool(message.pagination);
            }

            if (message.page != null && message.hasOwnProperty("page")) {
                writer.uint32(16).int32(message.page);
            }

            if (message.size != null && message.hasOwnProperty("size")) {
                writer.uint32(24).int32(message.size);
            }

            if (message.sort != null && message.hasOwnProperty("sort")) {
                writer.uint32(34).string(message.sort);
            }

            return writer;
        }

        static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): ResourceProto.PageablePb {
            if (!(reader instanceof $Reader)) {
                reader = $Reader.create(reader);
            }
            let end = length === undefined ? reader.len : reader.pos + length;
            let message = new ResourceProto.PageablePb();
            while (reader.pos < end) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1: {
                        message.pagination = reader.bool();
                        break;
                    }
                    case 2: {
                        message.page = reader.int32();
                        break;
                    }
                    case 3: {
                        message.size = reader.int32();
                        break;
                    }
                    case 4: {
                        message.sort = reader.string();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        }
    }

    export interface IPagingPb {
        page: number;
        size: number;
        totalCount: number;
        totalPage: number;
    }

    export class PagingPb implements IPagingPb {
        page!: number;
        size!: number;
        totalCount!: number;
        totalPage!: number;
        META: () => Webpb.WebpbMeta;

        private constructor(p: IPagingPb) {
            Webpb.assign(p, this, []);
            this.META = () => ({
                class: 'PagingPb',
                method: '',
                path: ''
            });
        }

        static create(properties: IPagingPb): PagingPb {
            return new PagingPb(properties);
        }

        static encode(message: IPagingPb, writer?: $protobuf.Writer): $protobuf.Writer {
            if (!writer) {
                writer = $Writer.create();
            }
            writer.uint32(8).int32(message.page);
            writer.uint32(16).int32(message.size);
            writer.uint32(24).int32(message.totalCount);
            writer.uint32(32).int32(message.totalPage);
            return writer;
        }

        static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): ResourceProto.PagingPb {
            if (!(reader instanceof $Reader)) {
                reader = $Reader.create(reader);
            }
            let end = length === undefined ? reader.len : reader.pos + length;
            let message = new ResourceProto.PagingPb();
            while (reader.pos < end) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1: {
                        message.page = reader.int32();
                        break;
                    }
                    case 2: {
                        message.size = reader.int32();
                        break;
                    }
                    case 3: {
                        message.totalCount = reader.int32();
                        break;
                    }
                    case 4: {
                        message.totalPage = reader.int32();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
                if (!message.hasOwnProperty("page")) {
                    throw $util.ProtocolError("missing required 'page'", { instance: message });
                }
                if (!message.hasOwnProperty("size")) {
                    throw $util.ProtocolError("missing required 'size'", { instance: message });
                }
                if (!message.hasOwnProperty("totalCount")) {
                    throw $util.ProtocolError("missing required 'totalCount'", { instance: message });
                }
                if (!message.hasOwnProperty("totalPage")) {
                    throw $util.ProtocolError("missing required 'totalPage'", { instance: message });
                }
            }
            return message;
        }
    }
}
