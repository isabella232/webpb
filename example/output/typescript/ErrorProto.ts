// Code generated by Webpb compiler, do not edit.
// https://github.com/jg513/webpb

import * as $protobuf from "protobufjs";
import { Webpb } from 'webpb';

const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

export namespace ErrorProto {
    export enum ErrorCode {
        OK = 0,
        ERROR = 1,
    }

    export interface IErrorMessage {
        code: ErrorProto.ErrorCode;
        message?: string;
    }

    export class ErrorMessage implements IErrorMessage {
        code!: ErrorProto.ErrorCode;
        message?: string;
        META: () => Webpb.WebpbMeta;

        private constructor(p: IErrorMessage) {
            Webpb.assign(p, this, []);
            this.META = () => ({
                class: 'ErrorMessage',
                method: '',
                path: ''
            });
        }

        static create(properties: IErrorMessage): ErrorMessage {
            return new ErrorMessage(properties);
        }

        static encode(message: IErrorMessage, writer?: $protobuf.Writer): $protobuf.Writer {
            if (!writer) {
                writer = $Writer.create();
            }
            ErrorProto.ErrorCode.encode(message.code, writer.uint32(10).fork()).ldelim();
            if (message.message != null && message.hasOwnProperty("message")) {
                writer.uint32(18).string(message.message);
            }

            return writer;
        }

        static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): ErrorProto.ErrorMessage {
            if (!(reader instanceof $Reader)) {
                reader = $Reader.create(reader);
            }
            let end = length === undefined ? reader.len : reader.pos + length;
            let message = new ErrorProto.ErrorMessage();
            while (reader.pos < end) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1: {
                        message.code = ErrorProto.ErrorCode.decode(reader, reader.uint32());
                        break;
                    }
                    case 2: {
                        message.message = reader.string();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
                if (!message.hasOwnProperty("code")) {
                    throw $util.ProtocolError("missing required 'code'", { instance: message });
                }
            }
            return message;
        }
    }
}
