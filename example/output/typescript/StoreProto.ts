// Code generated by Webpb compiler, do not edit.
// https://github.com/jg513/webpb

import * as $protobuf from "protobufjs";
import { Webpb } from 'webpb';

const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

import { ResourceProto } from './ResourceProto';

import { null } from './null';

export namespace StoreProto {
    export interface IStorePb {
        id: number;
        name: string;
        city: number;
    }

    export class StorePb implements IStorePb {
        id!: number;
        name: string = "store";
        city: number = 100;
        META: () => Webpb.WebpbMeta;

        private constructor(p: IStorePb) {
            Webpb.assign(p, this, []);
            this.META = () => ({
                class: 'StorePb',
                method: '',
                path: ''
            });
        }

        static create(properties: IStorePb): StorePb {
            return new StorePb(properties);
        }

        static encode(message: IStorePb, writer?: $protobuf.Writer): $protobuf.Writer {
            if (!writer) {
                writer = $Writer.create();
            }
            writer.uint32(8).int32(message.id);
            writer.uint32(18).string(message.name);
            writer.uint32(24).int32(message.city);
            return writer;
        }

        static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): StoreProto.StorePb {
            if (!(reader instanceof $Reader)) {
                reader = $Reader.create(reader);
            }
            let end = length === undefined ? reader.len : reader.pos + length;
            let message = new StoreProto.StorePb();
            while (reader.pos < end) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1: {
                        message.id = reader.int32();
                        break;
                    }
                    case 2: {
                        message.name = reader.string();
                        break;
                    }
                    case 3: {
                        message.city = reader.int32();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
                if (!message.hasOwnProperty("id")) {
                    throw $util.ProtocolError("missing required 'id'", { instance: message });
                }
                if (!message.hasOwnProperty("name")) {
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                }
                if (!message.hasOwnProperty("city")) {
                    throw $util.ProtocolError("missing required 'city'", { instance: message });
                }
            }
            return message;
        }
    }

    export interface IProject {
    }

    export class Project implements IProject {
        META: () => Webpb.WebpbMeta;

        private constructor() {
            this.META = () => ({
                class: 'Project',
                method: '',
                path: ''
            });
        }

        static create(): Project {
            return new Project();
        }

        static encode(message: IProject, writer?: $protobuf.Writer): $protobuf.Writer {
            if (!writer) {
                writer = $Writer.create();
            }
            return writer;
        }

        static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): StoreProto.Project {
            if (!(reader instanceof $Reader)) {
                reader = $Reader.create(reader);
            }
            let end = length === undefined ? reader.len : reader.pos + length;
            let message = new StoreProto.Project();
            while (reader.pos < end) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        }
    }

    export interface IStoreRequest {
        id: number;
        email: string;
        valid?: boolean;
        data: map<string, int32>;
        projects: map<string, Project>;
        unpacked: number[];
        packed: number[];
        projectList: StoreProto.IProject[];
        project: StoreProto.IProject;
        max: number;
        longData: map<int64, int32>;
        projectData: map<int64, Project>;
    }

    export class StoreRequest implements IStoreRequest, Webpb.WebpbMessage {
        id!: number;
        email!: string;
        valid?: boolean;
        data!: map<string, int32>;
        projects!: map<string, Project>;
        unpacked!: number[];
        packed!: number[];
        projectList!: StoreProto.IProject[];
        project!: StoreProto.IProject;
        max!: number;
        longData!: map<int64, int32>;
        projectData!: map<int64, Project>;
        META: () => Webpb.WebpbMeta;

        private constructor(p: IStoreRequest) {
            Webpb.assign(p, this, ["id"]);
            this.META = () => ({
                class: 'StoreRequest',
                method: 'GET',
                path: `/stores/${p.id}`
            });
        }

        static create(properties: IStoreRequest): StoreRequest {
            return new StoreRequest(properties);
        }

        static encode(message: IStoreRequest, writer?: $protobuf.Writer): $protobuf.Writer {
            if (!writer) {
                writer = $Writer.create();
            }
            writer.uint32(8).int32(message.id);
            writer.uint32(18).string(message.email);
            if (message.valid != null && message.hasOwnProperty("valid")) {
                writer.uint32(24).bool(message.valid);
            }

            if (message.data != null && message.hasOwnProperty("data")) {
                for (let keys = Object.keys(message.data), i = 0; i < keys.length; ++i) {
                    writer.uint32(34).fork().uint32(10).string(keys[i]).uint32(16).int32(message.data[keys[i]]).ldelim();
                }
            }

            if (message.projects != null && message.hasOwnProperty("projects")) {
                for (let keys = Object.keys(message.projects), i = 0; i < keys.length; ++i) {
                    writer.uint32(42).fork().uint32(10).string(keys[i]);
                    StoreProto.Project.encode(message.projects[keys[i]], writer.project(18).fork()).ldelim().ldelim();
                }
            }

            if (message.unpacked != null && message.unpacked.length) {
                for (let i = 0; i < message.unpacked.length; ++i) {
                    writer.uint32(48).int32(message.unpacked[i]);
                }
            }

            if (message.packed != null && message.packed.length) {
                for (let i = 0; i < message.packed.length; ++i) {
                    writer.uint32(58).fork();
                    for (let i = 0; i < message.packed.length; ++i) {
                        writer.int32(message.packed[i]);
                    }

                    writer.ldelim();
                }
            }

            if (message.projectList != null && message.projectList.length) {
                for (let i = 0; i < message.projectList.length; ++i) {
                    StoreProto.Project.encode(message.projectList[i], writer.uint32(66).fork()).ldelim();
                }
            }

            StoreProto.Project.encode(message.project, writer.uint32(74).fork()).ldelim();
            writer.uint32(80).int64(message.max);
            if (message.longData != null && message.hasOwnProperty("longData")) {
                for (let keys = Object.keys(message.longData), i = 0; i < keys.length; ++i) {
                    writer.uint32(90).fork().uint32(8).int64(keys[i]).uint32(16).int32(message.longData[keys[i]]).ldelim();
                }
            }

            if (message.projectData != null && message.hasOwnProperty("projectData")) {
                for (let keys = Object.keys(message.projectData), i = 0; i < keys.length; ++i) {
                    writer.uint32(98).fork().uint32(8).int64(keys[i]);
                    StoreProto.Project.encode(message.projectData[keys[i]], writer.project(18).fork()).ldelim().ldelim();
                }
            }

            return writer;
        }

        static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): StoreProto.StoreRequest {
            if (!(reader instanceof $Reader)) {
                reader = $Reader.create(reader);
            }
            let end = length === undefined ? reader.len : reader.pos + length;
            let message = new StoreProto.StoreRequest();
            while (reader.pos < end) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1: {
                        message.id = reader.int32();
                        break;
                    }
                    case 2: {
                        message.email = reader.string();
                        break;
                    }
                    case 3: {
                        message.valid = reader.bool();
                        break;
                    }
                    case 4: {
                        reader.skip().pos++;
                        if (message.data === $util.emptyObject) {
                            message.data = {};
                        }
                        const key = reader.string();
                        reader.pos++;
                        message.data[key] = reader.int32();
                        break;
                    }
                    case 5: {
                        reader.skip().pos++;
                        if (message.projects === $util.emptyObject) {
                            message.projects = {};
                        }
                        const key = reader.string();
                        reader.pos++;
                        message.projects[key] = StoreProto.Project.decode(reader, reader.uint32());
                        break;
                    }
                    case 6: {
                        if (!(message.unpacked && message.unpacked.length)) {
                            message.unpacked = [];
                        }
                        if ((tag & 7) === 2) {
                            const end = reader.uint32() + reader.pos;
                            while (reader.pos < end) {
                                message.unpacked.push(reader.int32());
                            }
                        } else {
                            message.unpacked.push(reader.int32());
                        }
                        break;
                    }
                    case 7: {
                        if (!(message.packed && message.packed.length)) {
                            message.packed = [];
                        }
                        if ((tag & 7) === 2) {
                            const end = reader.uint32() + reader.pos;
                            while (reader.pos < end) {
                                message.packed.push(reader.int32());
                            }
                        } else {
                            message.packed.push(reader.int32());
                        }
                        break;
                    }
                    case 8: {
                        if (!(message.projectList && message.projectList.length)) {
                            message.projectList = [];
                        }
                        break;
                    }
                    case 9: {
                        message.project = StoreProto.Project.decode(reader, reader.uint32());
                        break;
                    }
                    case 10: {
                        message.max = reader.int64();
                        break;
                    }
                    case 11: {
                        reader.skip().pos++;
                        if (message.longData === $util.emptyObject) {
                            message.longData = {};
                        }
                        const key = reader.int64();
                        reader.pos++;
                        message.longData[typeof key === "object" ? $util.longToHash(key) : key] = reader.int32();
                        break;
                    }
                    case 12: {
                        reader.skip().pos++;
                        if (message.projectData === $util.emptyObject) {
                            message.projectData = {};
                        }
                        const key = reader.int64();
                        reader.pos++;
                        message.projectData[typeof key === "object" ? $util.longToHash(key) : key] = StoreProto.Project.decode(reader, reader.uint32());
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
                if (!message.hasOwnProperty("id")) {
                    throw $util.ProtocolError("missing required 'id'", { instance: message });
                }
                if (!message.hasOwnProperty("email")) {
                    throw $util.ProtocolError("missing required 'email'", { instance: message });
                }
                if (!message.hasOwnProperty("project")) {
                    throw $util.ProtocolError("missing required 'project'", { instance: message });
                }
                if (!message.hasOwnProperty("max")) {
                    throw $util.ProtocolError("missing required 'max'", { instance: message });
                }
            }
            return message;
        }
    }

    export interface IStoreResponse {
        store: StoreProto.IStorePb;
        nested: StoreProto.StoreResponse.IStoreNestedPb;
    }

    export class StoreResponse implements IStoreResponse {
        store!: StoreProto.IStorePb;
        nested!: StoreProto.StoreResponse.IStoreNestedPb;
        META: () => Webpb.WebpbMeta;

        private constructor(p: IStoreResponse) {
            Webpb.assign(p, this, []);
            this.META = () => ({
                class: 'StoreResponse',
                method: '',
                path: ''
            });
        }

        static create(properties: IStoreResponse): StoreResponse {
            return new StoreResponse(properties);
        }

        static encode(message: IStoreResponse, writer?: $protobuf.Writer): $protobuf.Writer {
            if (!writer) {
                writer = $Writer.create();
            }
            StoreProto.StorePb.encode(message.store, writer.uint32(10).fork()).ldelim();
            StoreProto.StoreResponse.StoreNestedPb.encode(message.nested, writer.uint32(18).fork()).ldelim();
            return writer;
        }

        static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): StoreProto.StoreResponse {
            if (!(reader instanceof $Reader)) {
                reader = $Reader.create(reader);
            }
            let end = length === undefined ? reader.len : reader.pos + length;
            let message = new StoreProto.StoreResponse();
            while (reader.pos < end) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1: {
                        message.store = StoreProto.StorePb.decode(reader, reader.uint32());
                        break;
                    }
                    case 2: {
                        message.nested = StoreProto.StoreResponse.StoreNestedPb.decode(reader, reader.uint32());
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
                if (!message.hasOwnProperty("store")) {
                    throw $util.ProtocolError("missing required 'store'", { instance: message });
                }
                if (!message.hasOwnProperty("nested")) {
                    throw $util.ProtocolError("missing required 'nested'", { instance: message });
                }
            }
            return message;
        }
    }

    export namespace StoreResponse {
        export interface IStoreNestedPb {
            employee: string;
        }

        export class StoreNestedPb implements IStoreNestedPb {
            employee!: string;
            META: () => Webpb.WebpbMeta;

            private constructor(p: IStoreNestedPb) {
                Webpb.assign(p, this, []);
                this.META = () => ({
                    class: 'StoreNestedPb',
                    method: '',
                    path: ''
                });
            }

            static create(properties: IStoreNestedPb): StoreNestedPb {
                return new StoreNestedPb(properties);
            }

            static encode(message: IStoreNestedPb, writer?: $protobuf.Writer): $protobuf.Writer {
                if (!writer) {
                    writer = $Writer.create();
                }
                writer.uint32(10).string(message.employee);
                return writer;
            }

            static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): StoreProto.StoreResponse.StoreNestedPb {
                if (!(reader instanceof $Reader)) {
                    reader = $Reader.create(reader);
                }
                let end = length === undefined ? reader.len : reader.pos + length;
                let message = new StoreProto.StoreResponse.StoreNestedPb();
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            message.employee = reader.string();
                            break;
                        }
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                    if (!message.hasOwnProperty("employee")) {
                        throw $util.ProtocolError("missing required 'employee'", { instance: message });
                    }
                }
                return message;
            }
        }
    }

    export interface IStoreCurrentRequest {
    }

    export class StoreCurrentRequest implements IStoreCurrentRequest, Webpb.WebpbMessage {
        META: () => Webpb.WebpbMeta;

        private constructor() {
            this.META = () => ({
                class: 'StoreCurrentRequest',
                method: 'GET',
                path: `/stores/current`
            });
        }

        static create(): StoreCurrentRequest {
            return new StoreCurrentRequest();
        }

        static encode(message: IStoreCurrentRequest, writer?: $protobuf.Writer): $protobuf.Writer {
            if (!writer) {
                writer = $Writer.create();
            }
            return writer;
        }

        static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): StoreProto.StoreCurrentRequest {
            if (!(reader instanceof $Reader)) {
                reader = $Reader.create(reader);
            }
            let end = length === undefined ? reader.len : reader.pos + length;
            let message = new StoreProto.StoreCurrentRequest();
            while (reader.pos < end) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        }
    }

    export interface IEmptyPb {
    }

    export class EmptyPb implements IEmptyPb {
        META: () => Webpb.WebpbMeta;

        private constructor() {
            this.META = () => ({
                class: 'EmptyPb',
                method: '',
                path: ''
            });
        }

        static create(): EmptyPb {
            return new EmptyPb();
        }

        static encode(message: IEmptyPb, writer?: $protobuf.Writer): $protobuf.Writer {
            if (!writer) {
                writer = $Writer.create();
            }
            return writer;
        }

        static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): StoreProto.EmptyPb {
            if (!(reader instanceof $Reader)) {
                reader = $Reader.create(reader);
            }
            let end = length === undefined ? reader.len : reader.pos + length;
            let message = new StoreProto.EmptyPb();
            while (reader.pos < end) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        }
    }

    export namespace EmptyPb {
        export interface IEnclosingPb {
        }

        export class EnclosingPb implements IEnclosingPb {
            META: () => Webpb.WebpbMeta;

            private constructor() {
                this.META = () => ({
                    class: 'EnclosingPb',
                    method: '',
                    path: ''
                });
            }

            static create(): EnclosingPb {
                return new EnclosingPb();
            }

            static encode(message: IEnclosingPb, writer?: $protobuf.Writer): $protobuf.Writer {
                if (!writer) {
                    writer = $Writer.create();
                }
                return writer;
            }

            static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): StoreProto.EmptyPb.EnclosingPb {
                if (!(reader instanceof $Reader)) {
                    reader = $Reader.create(reader);
                }
                let end = length === undefined ? reader.len : reader.pos + length;
                let message = new StoreProto.EmptyPb.EnclosingPb();
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            }
        }
    }

    export interface IStoresRequest {
        pageable: ResourceProto.IPageablePb;
        type: number;
        city: number;
    }

    export class StoresRequest implements IStoresRequest, Webpb.WebpbMessage {
        pageable!: ResourceProto.IPageablePb;
        type!: number;
        city!: number;
        META: () => Webpb.WebpbMeta;

        private constructor(p: IStoresRequest) {
            Webpb.assign(p, this, ["pageable", "type"]);
            this.META = () => ({
                class: 'StoresRequest',
                method: 'POST',
                path: `/stores/${p.type}${Webpb.query({
                    page: Webpb.getter(p, 'pageable.page'),
                    size: Webpb.getter(p, 'pageable.size'),
                })}`
            });
        }

        static create(properties: IStoresRequest): StoresRequest {
            return new StoresRequest(properties);
        }

        static encode(message: IStoresRequest, writer?: $protobuf.Writer): $protobuf.Writer {
            if (!writer) {
                writer = $Writer.create();
            }
            ResourceProto.PageablePb.encode(message.pageable, writer.uint32(10).fork()).ldelim();
            writer.uint32(16).int32(message.type);
            writer.uint32(24).int32(message.city);
            return writer;
        }

        static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): StoreProto.StoresRequest {
            if (!(reader instanceof $Reader)) {
                reader = $Reader.create(reader);
            }
            let end = length === undefined ? reader.len : reader.pos + length;
            let message = new StoreProto.StoresRequest();
            while (reader.pos < end) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1: {
                        message.pageable = ResourceProto.PageablePb.decode(reader, reader.uint32());
                        break;
                    }
                    case 2: {
                        message.type = reader.int32();
                        break;
                    }
                    case 3: {
                        message.city = reader.int32();
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
                if (!message.hasOwnProperty("pageable")) {
                    throw $util.ProtocolError("missing required 'pageable'", { instance: message });
                }
                if (!message.hasOwnProperty("type")) {
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                }
                if (!message.hasOwnProperty("city")) {
                    throw $util.ProtocolError("missing required 'city'", { instance: message });
                }
            }
            return message;
        }
    }

    export interface IStoresResponse {
        stores: StoreProto.IStorePb;
        paging: ResourceProto.IPagingPb;
    }

    export class StoresResponse implements IStoresResponse {
        stores!: StoreProto.IStorePb;
        paging!: ResourceProto.IPagingPb;
        META: () => Webpb.WebpbMeta;

        private constructor(p: IStoresResponse) {
            Webpb.assign(p, this, []);
            this.META = () => ({
                class: 'StoresResponse',
                method: '',
                path: ''
            });
        }

        static create(properties: IStoresResponse): StoresResponse {
            return new StoresResponse(properties);
        }

        static encode(message: IStoresResponse, writer?: $protobuf.Writer): $protobuf.Writer {
            if (!writer) {
                writer = $Writer.create();
            }
            StoreProto.StorePb.encode(message.stores, writer.uint32(10).fork()).ldelim();
            ResourceProto.PagingPb.encode(message.paging, writer.uint32(18).fork()).ldelim();
            return writer;
        }

        static decode(reader: ($protobuf.Reader | Uint8Array), length?: number): StoreProto.StoresResponse {
            if (!(reader instanceof $Reader)) {
                reader = $Reader.create(reader);
            }
            let end = length === undefined ? reader.len : reader.pos + length;
            let message = new StoreProto.StoresResponse();
            while (reader.pos < end) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1: {
                        message.stores = StoreProto.StorePb.decode(reader, reader.uint32());
                        break;
                    }
                    case 2: {
                        message.paging = ResourceProto.PagingPb.decode(reader, reader.uint32());
                        break;
                    }
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
                if (!message.hasOwnProperty("stores")) {
                    throw $util.ProtocolError("missing required 'stores'", { instance: message });
                }
                if (!message.hasOwnProperty("paging")) {
                    throw $util.ProtocolError("missing required 'paging'", { instance: message });
                }
            }
            return message;
        }
    }
}
